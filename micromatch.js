/* eslint-disable */
!(function (e) { if (typeof exports === 'object' && typeof module !== 'undefined') { module.exports = e(); } else if (typeof define === 'function' && define.amd) { define([], e); } else { (typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this).micromatch = e(); } }(() => {
	return (function () { return function e(t, n, r) { function o(s, u) { if (!n[s]) { if (!t[s]) { const a = typeof require === 'function' && require; if (!u && a) { return a(s, !0); } if (i) { return i(s, !0); } const l = new Error(`Cannot find module '${s}'`); throw l.code = 'MODULE_NOT_FOUND', l; } const p = n[s] = { exports: {} }; t[s][0].call(p.exports, e => { return o(t[s][1][e] || e); }, p, p.exports, e, t, n, r); } return n[s].exports; } for (var i = typeof require === 'function' && require, s = 0; s < r.length; s++) { o(r[s]); } return o; }; }())({
		1: [ function (e, t, n) {
			'use strict'; const r = e('util'); const o = e('braces'); const i = e('picomatch'); const s = e('picomatch/lib/utils'); const u = e => typeof e === 'string' && (e === '' || e === './'); const a = (e, t, n) => {
				t = [].concat(t), e = [].concat(e); const r = new Set(); const o = new Set(); const s = new Set(); let u = 0; const
					a = e => { s.add(e.output), n && n.onResult && n.onResult(e); }; for (let s = 0; s < t.length; s++) { const l = i(String(t[s]), { ...n, onResult: a }, !0); const p = l.state.negated || l.state.negatedExtglob; p && u++; for (const t of e) { const e = l(t, !0); (p ? !e.isMatch : e.isMatch) && (p ? r.add(e.output) : (r.delete(e.output), o.add(e.output))); } } const l = (u === t.length ? [ ...s ] : [ ...o ]).filter(e => !r.has(e)); if (n && l.length === 0) { if (!0 === n.failglob) { throw new Error(`No matches found for "${t.join(', ')}"`); } if (!0 === n.nonull || !0 === n.nullglob) { return n.unescape ? t.map(e => e.replace(/\\/g, '')) : t; } } return l;
			}; a.match = a, a.matcher = ((e, t) => i(e, t)), a.any = a.isMatch = ((e, t, n) => i(t, n)(e)), a.not = ((e, t, n = {}) => {
				t = [].concat(t).map(String); const r = new Set(); const o = []; const
					i = a(e, t, { ...n, onResult: e => { n.onResult && n.onResult(e), o.push(e.output); } }); for (const e of o) { i.includes(e) || r.add(e); } return [ ...r ];
			}), a.contains = ((e, t, n) => { if (typeof e !== 'string') { throw new TypeError(`Expected a string: "${r.inspect(e)}"`); } if (Array.isArray(t)) { return t.some(t => a.contains(e, t, n)); } if (typeof t === 'string') { if (u(e) || u(t)) { return !1; } if (e.includes(t) || e.startsWith('./') && e.slice(2).includes(t)) { return !0; } } return a.isMatch(e, t, { ...n, contains: !0 }); }), a.matchKeys = ((e, t, n) => { if (!s.isObject(e)) { throw new TypeError('Expected the first argument to be an object'); } const r = a(Object.keys(e), t, n); const o = {}; for (const t of r) { o[t] = e[t]; } return o; }), a.some = ((e, t, n) => { const r = [].concat(e); for (const e of [].concat(t)) { const t = i(String(e), n); if (r.some(e => t(e))) { return !0; } } return !1; }), a.every = ((e, t, n) => { const r = [].concat(e); for (const e of [].concat(t)) { const t = i(String(e), n); if (!r.every(e => t(e))) { return !1; } } return !0; }), a.all = ((e, t, n) => { if (typeof e !== 'string') { throw new TypeError(`Expected a string: "${r.inspect(e)}"`); } return [].concat(t).every(t => i(t, n)(e)); }), a.capture = ((e, t, n) => { const r = s.isWindows(n); const o = i.makeRe(String(e), { ...n, capture: !0 }).exec(r ? s.toPosixSlashes(t) : t); if (o) { return o.slice(1).map(e => (void 0 === e ? '' : e)); } }), a.makeRe = ((...e) => i.makeRe(...e)), a.scan = ((...e) => i.scan(...e)), a.parse = ((e, t) => { const n = []; for (const r of [].concat(e || [])) { for (const e of o(String(r), t)) { n.push(i.parse(e, t)); } } return n; }), a.braces = ((e, t) => { if (typeof e !== 'string') { throw new TypeError('Expected a string'); } return t && !0 === t.nobrace || !/\{.*\}/.test(e) ? [ e ] : o(e, t); }), a.braceExpand = ((e, t) => { if (typeof e !== 'string') { throw new TypeError('Expected a string'); } return a.braces(e, { ...t, expand: !0 }); }), t.exports = a;
		}, { 'braces': 2, 'picomatch': 11, 'picomatch/lib/utils': 16, 'util': 22 }], 2: [ function (e, t, n) { 'use strict'; const r = e('./lib/stringify'); const o = e('./lib/compile'); const i = e('./lib/expand'); const s = e('./lib/parse'); const u = (e, t = {}) => { let n = []; if (Array.isArray(e)) { for (const r of e) { const e = u.create(r, t); Array.isArray(e) ? n.push(...e) : n.push(e); } } else { n = [].concat(u.create(e, t)); } return t && !0 === t.expand && !0 === t.nodupes && (n = [ ...new Set(n) ]), n; }; u.parse = ((e, t = {}) => s(e, t)), u.stringify = ((e, t = {}) => r(typeof e === 'string' ? u.parse(e, t) : e, t)), u.compile = ((e, t = {}) => (typeof e === 'string' && (e = u.parse(e, t)), o(e, t))), u.expand = ((e, t = {}) => { typeof e === 'string' && (e = u.parse(e, t)); let n = i(e, t); return !0 === t.noempty && (n = n.filter(Boolean)), !0 === t.nodupes && (n = [ ...new Set(n) ]), n; }), u.create = ((e, t = {}) => (e === '' || e.length < 3 ? [ e ] : !0 !== t.expand ? u.compile(e, t) : u.expand(e, t))), t.exports = u; }, { './lib/compile': 3, './lib/expand': 5, './lib/parse': 6, './lib/stringify': 7 }], 3: [ function (e, t, n) { 'use strict'; const r = e('fill-range'); const o = e('./utils'); t.exports = ((e, t = {}) => { const n = (e, i = {}) => { const s = o.isInvalidBrace(i); const u = !0 === e.invalid && !0 === t.escapeInvalid; const a = !0 === s || !0 === u; const l = !0 === t.escapeInvalid ? '\\' : ''; let p = ''; if (!0 === e.isOpen) { return l + e.value; } if (!0 === e.isClose) { return l + e.value; } if (e.type === 'open') { return a ? l + e.value : '('; } if (e.type === 'close') { return a ? l + e.value : ')'; } if (e.type === 'comma') { return e.prev.type === 'comma' ? '' : a ? e.value : '|'; } if (e.value) { return e.value; } if (e.nodes && e.ranges > 0) { const n = o.reduce(e.nodes); const i = r(...n, { ...t, wrap: !1, toRegex: !0 }); if (i.length !== 0) { return n.length > 1 && i.length > 1 ? `(${i})` : i; } } if (e.nodes) { for (const t of e.nodes) { p += n(t, e); } } return p; }; return n(e); }); }, { './utils': 8, 'fill-range': 9 }], 4: [ function (e, t, n) { 'use strict'; t.exports = { MAX_LENGTH: 65536, CHAR_0: '0', CHAR_9: '9', CHAR_UPPERCASE_A: 'A', CHAR_LOWERCASE_A: 'a', CHAR_UPPERCASE_Z: 'Z', CHAR_LOWERCASE_Z: 'z', CHAR_LEFT_PARENTHESES: '(', CHAR_RIGHT_PARENTHESES: ')', CHAR_ASTERISK: '*', CHAR_AMPERSAND: '&', CHAR_AT: '@', CHAR_BACKSLASH: '\\', CHAR_BACKTICK: '`', CHAR_CARRIAGE_RETURN: '\r', CHAR_CIRCUMFLEX_ACCENT: '^', CHAR_COLON: ':', CHAR_COMMA: ',', CHAR_DOLLAR: '$', CHAR_DOT: '.', CHAR_DOUBLE_QUOTE: '"', CHAR_EQUAL: '=', CHAR_EXCLAMATION_MARK: '!', CHAR_FORM_FEED: '\f', CHAR_FORWARD_SLASH: '/', CHAR_HASH: '#', CHAR_HYPHEN_MINUS: '-', CHAR_LEFT_ANGLE_BRACKET: '<', CHAR_LEFT_CURLY_BRACE: '{', CHAR_LEFT_SQUARE_BRACKET: '[', CHAR_LINE_FEED: '\n', CHAR_NO_BREAK_SPACE: ' ', CHAR_PERCENT: '%', CHAR_PLUS: '+', CHAR_QUESTION_MARK: '?', CHAR_RIGHT_ANGLE_BRACKET: '>', CHAR_RIGHT_CURLY_BRACE: '}', CHAR_RIGHT_SQUARE_BRACKET: ']', CHAR_SEMICOLON: ';', CHAR_SINGLE_QUOTE: "'", CHAR_SPACE: ' ', CHAR_TAB: '\t', CHAR_UNDERSCORE: '_', CHAR_VERTICAL_LINE: '|', CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\ufeff' }; }, {}], 5: [ function (e, t, n) { 'use strict'; const r = e('fill-range'); const o = e('./stringify'); const i = e('./utils'); const s = (e = '', t = '', n = !1) => { const r = []; if (e = [].concat(e), !(t = [].concat(t)).length) { return e; } if (!e.length) { return n ? i.flatten(t).map(e => `{${e}}`) : t; } for (const o of e) { if (Array.isArray(o)) { for (const e of o) { r.push(s(e, t, n)); } } else { for (let e of t) { !0 === n && typeof e === 'string' && (e = `{${e}}`), r.push(Array.isArray(e) ? s(o, e, n) : o + e); } } } return i.flatten(r); }; t.exports = ((e, t = {}) => { const n = void 0 === t.rangeLimit ? 1e3 : t.rangeLimit; const u = (e, a = {}) => { e.queue = []; let l = a; let p = a.queue; for (;l.type !== 'brace' && l.type !== 'root' && l.parent;) { p = (l = l.parent).queue; } if (e.invalid || e.dollar) { return void p.push(s(p.pop(), o(e, t))); } if (e.type === 'brace' && !0 !== e.invalid && e.nodes.length === 2) { return void p.push(s(p.pop(), [ '{}' ])); } if (e.nodes && e.ranges > 0) { const u = i.reduce(e.nodes); if (i.exceedsLimit(...u, t.step, n)) { throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.'); } let a = r(...u, t); return a.length === 0 && (a = o(e, t)), p.push(s(p.pop(), a)), void(e.nodes = []); } const c = i.encloseBrace(e); let f = e.queue; let g = e; for (;g.type !== 'brace' && g.type !== 'root' && g.parent;) { f = (g = g.parent).queue; } for (let t = 0; t < e.nodes.length; t++) { const n = e.nodes[t]; n.type !== 'comma' || e.type !== 'brace' ? n.type !== 'close' ? n.value && n.type !== 'open' ? f.push(s(f.pop(), n.value)) : n.nodes && u(n, e) : p.push(s(p.pop(), f, c)) : (t === 1 && f.push(''), f.push('')); } return f; }; return i.flatten(u(e)); }); }, { './stringify': 7, './utils': 8, 'fill-range': 9 }], 6: [ function (e, t, n) { 'use strict'; const r = e('./stringify'); const { MAX_LENGTH:o, CHAR_BACKSLASH:i, CHAR_BACKTICK:s, CHAR_COMMA:u, CHAR_DOT:a, CHAR_LEFT_PARENTHESES:l, CHAR_RIGHT_PARENTHESES:p, CHAR_LEFT_CURLY_BRACE:c, CHAR_RIGHT_CURLY_BRACE:f, CHAR_LEFT_SQUARE_BRACKET:g, CHAR_RIGHT_SQUARE_BRACKET:h, CHAR_DOUBLE_QUOTE:A, CHAR_SINGLE_QUOTE:y, CHAR_NO_BREAK_SPACE:R, CHAR_ZERO_WIDTH_NOBREAK_SPACE:d } = e('./constants'); t.exports = ((e, t = {}) => { if (typeof e !== 'string') { throw new TypeError('Expected a string'); } const n = t || {}; const _ = typeof n.maxLength === 'number' ? Math.min(o, n.maxLength) : o; if (e.length > _) { throw new SyntaxError(`Input length (${e.length}), exceeds max characters (${_})`); } let E; const b = { type: 'root', input: e, nodes: [] }; const C = [ b ]; let v = b; let x = b; let m = 0; const S = e.length; let H = 0; let T = 0; const O = () => e[H++]; const $ = e => { if (e.type === 'text' && x.type === 'dot' && (x.type = 'text'), !x || x.type !== 'text' || e.type !== 'text') { return v.nodes.push(e), e.parent = v, e.prev = x, x = e, e; } x.value += e.value; }; for ($({ type: 'bos' }); H < S;) { if (v = C[C.length - 1], (E = O()) !== d && E !== R) { if (E !== i) { if (E !== h) { if (E !== g) { if (E !== l) { if (E !== p) { if (E !== A && E !== y && E !== s) { if (E !== c) { if (E !== f) { if (E === u && T > 0) { if (v.ranges > 0) { v.ranges = 0; const e = v.nodes.shift(); v.nodes = [ e, { type: 'text', value: r(v) }]; }$({ type: 'comma', value: E }), v.commas++; } else if (E === a && T > 0 && v.commas === 0) { const e = v.nodes; if (T === 0 || e.length === 0) { $({ type: 'text', value: E }); continue; } if (x.type === 'dot') { if (v.range = [], x.value += E, x.type = 'range', v.nodes.length !== 3 && v.nodes.length !== 5) { v.invalid = !0, v.ranges = 0, x.type = 'text'; continue; }v.ranges++, v.args = []; continue; } if (x.type === 'range') { e.pop(); const t = e[e.length - 1]; t.value += x.value + E, x = t, v.ranges--; continue; }$({ type: 'dot', value: E }); } else { $({ type: 'text', value: E }); } } else { if (v.type !== 'brace') { $({ type: 'text', value: E }); continue; } const e = 'close'; (v = C.pop()).close = !0, $({ type: e, value: E }), T--, v = C[C.length - 1]; } } else { T++; const e = x.value && x.value.slice(-1) === '$' || !0 === v.dollar; v = $({ type: 'brace', open: !0, close: !1, dollar: e, depth: T, commas: 0, ranges: 0, nodes: [] }), C.push(v), $({ type: 'open', value: E }); } } else { let e; const n = E; for (!0 !== t.keepQuotes && (E = ''); H < S && (e = O());) { if (e !== i) { if (e === n) { !0 === t.keepQuotes && (E += e); break; }E += e; } else { E += e + O(); } }$({ type: 'text', value: E }); } } else { if (v.type !== 'paren') { $({ type: 'text', value: E }); continue; }v = C.pop(), $({ type: 'text', value: E }), v = C[C.length - 1]; } } else { v = $({ type: 'paren', nodes: [] }), C.push(v), $({ type: 'text', value: E }); } } else { let e; for (m++; H < S && (e = O());) { if (E += e, e !== g) { if (e !== i) { if (e === h && --m == 0) { break; } } else { E += O(); } } else { m++; } }$({ type: 'text', value: E }); } } else { $({ type: 'text', value: `\\${E}` }); } } else { $({ type: 'text', value: (t.keepEscaping ? E : '') + O() }); } } } do { if ((v = C.pop()).type !== 'root') { v.nodes.forEach(e => { e.nodes || (e.type === 'open' && (e.isOpen = !0), e.type === 'close' && (e.isClose = !0), e.nodes || (e.type = 'text'), e.invalid = !0); }); const e = C[C.length - 1]; const t = e.nodes.indexOf(v); e.nodes.splice(t, 1, ...v.nodes); } } while (C.length > 0); return $({ type: 'eos' }), b; }); }, { './constants': 4, './stringify': 7 }], 7: [ function (e, t, n) { 'use strict'; const r = e('./utils'); t.exports = ((e, t = {}) => { const n = (e, o = {}) => { const i = t.escapeInvalid && r.isInvalidBrace(o); const s = !0 === e.invalid && !0 === t.escapeInvalid; let u = ''; if (e.value) { return (i || s) && r.isOpenOrClose(e) ? `\\${e.value}` : e.value; } if (e.value) { return e.value; } if (e.nodes) { for (const t of e.nodes) { u += n(t); } } return u; }; return n(e); }); }, { './utils': 8 }], 8: [ function (e, t, n) { 'use strict'; n.isInteger = (e => (typeof e === 'number' ? Number.isInteger(e) : typeof e === 'string' && e.trim() !== '' && Number.isInteger(Number(e)))), n.find = ((e, t) => e.nodes.find(e => e.type === t)), n.exceedsLimit = ((e, t, r = 1, o) => !1 !== o && (!(!n.isInteger(e) || !n.isInteger(t)) && (Number(t) - Number(e)) / Number(r) >= o)), n.escapeNode = ((e, t = 0, n) => { const r = e.nodes[t]; r && (n && r.type === n || r.type === 'open' || r.type === 'close') && !0 !== r.escaped && (r.value = `\\${r.value}`, r.escaped = !0); }), n.encloseBrace = (e => e.type === 'brace' && (e.commas >> 0 + e.ranges >> 0 == 0 && (e.invalid = !0, !0))), n.isInvalidBrace = (e => e.type === 'brace' && (!(!0 !== e.invalid && !e.dollar) || (e.commas >> 0 + e.ranges >> 0 == 0 ? (e.invalid = !0, !0) : (!0 !== e.open || !0 !== e.close) && (e.invalid = !0, !0)))), n.isOpenOrClose = (e => e.type === 'open' || e.type === 'close' || (!0 === e.open || !0 === e.close)), n.reduce = (e => e.reduce((e, t) => (t.type === 'text' && e.push(t.value), t.type === 'range' && (t.type = 'text'), e), [])), n.flatten = ((...e) => { const t = []; const n = e => { for (let r = 0; r < e.length; r++) { const o = e[r]; Array.isArray(o) ? n(o, t) : void 0 !== o && t.push(o); } return t; }; return n(e), t; }); }, {}], 9: [ function (e, t, n) { 'use strict'; const r = e('util'); const o = e('to-regex-range'); const i = e => e !== null && typeof e === 'object' && !Array.isArray(e); const s = e => typeof e === 'number' || typeof e === 'string' && e !== ''; const u = e => Number.isInteger(+e); const a = e => { let t = `${e}`; let n = -1; if (t[0] === '-' && (t = t.slice(1)), t === '0') { return !1; } for (;t[++n] === '0';) {  } return n > 0; }; const l = (e, t, n) => { if (t > 0) { const n = e[0] === '-' ? '-' : ''; n && (e = e.slice(1)), e = n + e.padStart(n ? t - 1 : t, '0'); } return !1 === n ? String(e) : e; }; const p = (e, t) => { const n = e[0] === '-' ? '-' : ''; for (n && (e = e.slice(1), t--); e.length < t;) { e = `0${e}`; } return n ? `-${e}` : e; }; const c = (e, t, n, r) => { if (n) { return o(e, t, { wrap: !1, ...r }); } const i = String.fromCharCode(e); return e === t ? i : `[${i}-${String.fromCharCode(t)}]`; }; const f = (e, t, n) => { if (Array.isArray(e)) { const t = !0 === n.wrap; const r = n.capture ? '' : '?:'; return t ? `(${r}${e.join('|')})` : e.join('|'); } return o(e, t, n); }; const g = (...e) => new RangeError(`Invalid range arguments: ${r.inspect(...e)}`); const h = (e, t, n) => { if (!0 === n.strictRanges) { throw g([ e, t ]); } return []; }; const A = (e, t, n = 1, r = {}) => { let o = Number(e); let i = Number(t); if (!Number.isInteger(o) || !Number.isInteger(i)) { if (!0 === r.strictRanges) { throw g([ e, t ]); } return []; }o === 0 && (o = 0), i === 0 && (i = 0); const s = o > i; const u = String(e); const h = String(t); const A = String(n); n = Math.max(Math.abs(n), 1); const y = a(u) || a(h) || a(A); const R = y ? Math.max(u.length, h.length, A.length) : 0; const d = !1 === y && !1 === ((e, t, n) => typeof e === 'string' || typeof t === 'string' || !0 === n.stringify)(e, t, r); const _ = r.transform || (e => t => (!0 === e ? Number(t) : String(t)))(d); if (r.toRegex && n === 1) { return c(p(e, R), p(t, R), !0, r); } const E = { negatives: [], positives: [] }; const b = e => E[e < 0 ? 'negatives' : 'positives'].push(Math.abs(e)); const C = []; let v = 0; for (;s ? o >= i : o <= i;) { !0 === r.toRegex && n > 1 ? b(o) : C.push(l(_(o, v), R, d)), o = s ? o - n : o + n, v++; } return !0 === r.toRegex ? n > 1 ? ((e, t) => { e.negatives.sort((e, t) => (e < t ? -1 : e > t ? 1 : 0)), e.positives.sort((e, t) => (e < t ? -1 : e > t ? 1 : 0)); let n; const r = t.capture ? '' : '?:'; let o = ''; let i = ''; return e.positives.length && (o = e.positives.join('|')), e.negatives.length && (i = `-(${r}${e.negatives.join('|')})`), n = o && i ? `${o}|${i}` : o || i, t.wrap ? `(${r}${n})` : n; })(E, r) : f(C, null, { wrap: !1, ...r }) : C; }; const y = (e, t, n, r = {}) => { if (t == null && s(e)) { return [ e ]; } if (!s(e) || !s(t)) { return h(e, t, r); } if (typeof n === 'function') { return y(e, t, 1, { transform: n }); } if (i(n)) { return y(e, t, 0, n); } const o = { ...r }; return !0 === o.capture && (o.wrap = !0), n = n || o.step || 1, u(n) ? u(e) && u(t) ? A(e, t, n, o) : ((e, t, n = 1, r = {}) => { if (!u(e) && e.length > 1 || !u(t) && t.length > 1) { return h(e, t, r); } const o = r.transform || (e => String.fromCharCode(e)); let i = `${e}`.charCodeAt(0); const s = `${t}`.charCodeAt(0); const a = i > s; const l = Math.min(i, s); const p = Math.max(i, s); if (r.toRegex && n === 1) { return c(l, p, !1, r); } const g = []; let A = 0; for (;a ? i >= s : i <= s;) { g.push(o(i, A)), i = a ? i - n : i + n, A++; } return !0 === r.toRegex ? f(g, null, { wrap: !1, options: r }) : g; })(e, t, Math.max(Math.abs(n), 1), o) : n == null || i(n) ? y(e, t, 1, n) : ((e, t) => { if (!0 === t.strictRanges) { throw new TypeError(`Expected step "${e}" to be a number`); } return []; })(n, o); }; t.exports = y; }, { 'to-regex-range': 17, 'util': 22 }], 10: [ function (e, t, n) { 'use strict'; t.exports = function (e) { return typeof e === 'number' ? e - e == 0 : typeof e === 'string' && e.trim() !== '' && (Number.isFinite ? Number.isFinite(+e) : isFinite(+e)); }; }, {}], 11: [ function (e, t, n) { 'use strict'; t.exports = e('./lib/picomatch'); }, { './lib/picomatch': 14 }], 12: [ function (e, t, n) { 'use strict'; const r = e('path'); const o = { DOT_LITERAL: '\\.', PLUS_LITERAL: '\\+', QMARK_LITERAL: '\\?', SLASH_LITERAL: '\\/', ONE_CHAR: '(?=.)', QMARK: '[^/]', END_ANCHOR: '(?:\\/|$)', DOTS_SLASH: '\\.{1,2}(?:\\/|$)', NO_DOT: '(?!\\.)', NO_DOTS: '(?!(?:^|\\/)\\.{1,2}(?:\\/|$))', NO_DOT_SLASH: '(?!\\.{0,1}(?:\\/|$))', NO_DOTS_SLASH: '(?!\\.{1,2}(?:\\/|$))', QMARK_NO_DOT: '[^.\\/]', STAR: '[^/]*?', START_ANCHOR: '(?:^|\\/)' }; const i = { ...o, SLASH_LITERAL: '[\\\\/]', QMARK: '[^\\\\/]', STAR: '[^\\\\/]*?', DOTS_SLASH: '\\.{1,2}(?:[\\\\/]|$)', NO_DOT: '(?!\\.)', NO_DOTS: '(?!(?:^|[\\\\/])\\.{1,2}(?:[\\\\/]|$))', NO_DOT_SLASH: '(?!\\.{0,1}(?:[\\\\/]|$))', NO_DOTS_SLASH: '(?!\\.{1,2}(?:[\\\\/]|$))', QMARK_NO_DOT: '[^.\\\\/]', START_ANCHOR: '(?:^|[\\\\/])', END_ANCHOR: '(?:[\\\\/]|$)' }; t.exports = { MAX_LENGTH: 65536, POSIX_REGEX_SOURCE: { alnum: 'a-zA-Z0-9', alpha: 'a-zA-Z', ascii: '\\x00-\\x7F', blank: ' \\t', cntrl: '\\x00-\\x1F\\x7F', digit: '0-9', graph: '\\x21-\\x7E', lower: 'a-z', print: '\\x20-\\x7E ', punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~", space: ' \\t\\r\\n\\v\\f', upper: 'A-Z', word: 'A-Za-z0-9_', xdigit: 'A-Fa-f0-9' }, REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g, REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/, REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/, REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g, REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g, REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g, REPLACEMENTS: { '***': '*', '**/**': '**', '**/**/**': '**' }, CHAR_0: 48, CHAR_9: 57, CHAR_UPPERCASE_A: 65, CHAR_LOWERCASE_A: 97, CHAR_UPPERCASE_Z: 90, CHAR_LOWERCASE_Z: 122, CHAR_LEFT_PARENTHESES: 40, CHAR_RIGHT_PARENTHESES: 41, CHAR_ASTERISK: 42, CHAR_AMPERSAND: 38, CHAR_AT: 64, CHAR_BACKWARD_SLASH: 92, CHAR_CARRIAGE_RETURN: 13, CHAR_CIRCUMFLEX_ACCENT: 94, CHAR_COLON: 58, CHAR_COMMA: 44, CHAR_DOT: 46, CHAR_DOUBLE_QUOTE: 34, CHAR_EQUAL: 61, CHAR_EXCLAMATION_MARK: 33, CHAR_FORM_FEED: 12, CHAR_FORWARD_SLASH: 47, CHAR_GRAVE_ACCENT: 96, CHAR_HASH: 35, CHAR_HYPHEN_MINUS: 45, CHAR_LEFT_ANGLE_BRACKET: 60, CHAR_LEFT_CURLY_BRACE: 123, CHAR_LEFT_SQUARE_BRACKET: 91, CHAR_LINE_FEED: 10, CHAR_NO_BREAK_SPACE: 160, CHAR_PERCENT: 37, CHAR_PLUS: 43, CHAR_QUESTION_MARK: 63, CHAR_RIGHT_ANGLE_BRACKET: 62, CHAR_RIGHT_CURLY_BRACE: 125, CHAR_RIGHT_SQUARE_BRACKET: 93, CHAR_SEMICOLON: 59, CHAR_SINGLE_QUOTE: 39, CHAR_SPACE: 32, CHAR_TAB: 9, CHAR_UNDERSCORE: 95, CHAR_VERTICAL_LINE: 124, CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, SEP: r.sep, extglobChars: e => ({ '!': { type: 'negate', open: '(?:(?!(?:', close: `))${e.STAR})` }, '?': { type: 'qmark', open: '(?:', close: ')?' }, '+': { type: 'plus', open: '(?:', close: ')+' }, '*': { type: 'star', open: '(?:', close: ')*' }, '@': { type: 'at', open: '(?:', close: ')' } }), globChars: e => (!0 === e ? i : o) }; }, { path: 18 }], 13: [ function (e, t, n) { 'use strict'; const r = e('./constants'); const o = e('./utils'); const { MAX_LENGTH:i, POSIX_REGEX_SOURCE:s, REGEX_NON_SPECIAL_CHARS:u, REGEX_SPECIAL_CHARS_BACKREF:a, REPLACEMENTS:l } = r; const p = (e, t) => { if (typeof t.expandRange === 'function') { return t.expandRange(...e, t); } e.sort(); const n = `[${e.join('-')}]`; try { new RegExp(n); } catch (t) { return e.map(e => o.escapeRegex(e)).join('..'); } return n; }; const c = (e, t) => `Missing ${e}: "${t}" - use "\\\\${t}" to match literal characters`; const f = (e, t) => { if (typeof e !== 'string') { throw new TypeError('Expected a string'); } e = l[e] || e; const n = { ...t }; const f = typeof n.maxLength === 'number' ? Math.min(i, n.maxLength) : i; let g = e.length; if (g > f) { throw new SyntaxError(`Input length: ${g}, exceeds maximum allowed length: ${f}`); } const h = { type: 'bos', value: '', output: n.prepend || '' }; const A = [ h ]; const y = n.capture ? '' : '?:'; const R = o.isWindows(t); const d = r.globChars(R); const _ = r.extglobChars(d); const { DOT_LITERAL:E, PLUS_LITERAL:b, SLASH_LITERAL:C, ONE_CHAR:v, DOTS_SLASH:x, NO_DOT:m, NO_DOT_SLASH:S, NO_DOTS_SLASH:H, QMARK:T, QMARK_NO_DOT:O, STAR:$, START_ANCHOR:L } = d; const w = e => `(${y}(?:(?!${L}${e.dot ? x : E}).)*?)`; const N = n.dot ? '' : m; const k = n.dot ? T : O; let I = !0 === n.bash ? w(n) : $; n.capture && (I = `(${I})`), typeof n.noext === 'boolean' && (n.noextglob = n.noext); const M = { input: e, index: -1, start: 0, dot: !0 === n.dot, consumed: '', output: '', prefix: '', backtrack: !1, negated: !1, brackets: 0, braces: 0, parens: 0, quotes: 0, globstar: !1, tokens: A }; e = o.removePrefix(e, M), g = e.length; const B = []; const D = []; const P = []; let G; let U = h; const K = () => M.index === g - 1; const j = M.peek = ((t = 1) => e[M.index + t]); const F = M.advance = (() => e[++M.index]); const Q = () => e.slice(M.index + 1); const z = (e = '', t = 0) => { M.consumed += e, M.index += t; }; const X = e => { M.output += e.output != null ? e.output : e.value, z(e.value); }; const W = () => { let e = 1; for (;j() === '!' && (j(2) !== '(' || j(3) === '?');) { F(), M.start++, e++; } return e % 2 != 0 && (M.negated = !0, M.start++, !0); }; const Z = e => { M[e]++, P.push(e); }; const q = e => { M[e]--, P.pop(); }; const Y = e => { if (U.type === 'globstar') { const t = M.braces > 0 && (e.type === 'comma' || e.type === 'brace'); const n = !0 === e.extglob || B.length && (e.type === 'pipe' || e.type === 'paren'); e.type === 'slash' || e.type === 'paren' || t || n || (M.output = M.output.slice(0, -U.output.length), U.type = 'star', U.value = '*', U.output = I, M.output += U.output); } if (B.length && e.type !== 'paren' && !_[e.value] && (B[B.length - 1].inner += e.value), (e.value || e.output) && X(e), U && U.type === 'text' && e.type === 'text') { return U.value += e.value, void(U.output = (U.output || '') + e.value); } e.prev = U, A.push(e), U = e; }; const J = (e, t) => { const r = { ..._[t], conditions: 1, inner: '' }; r.prev = U, r.parens = M.parens, r.output = M.output; const o = (n.capture ? '(' : '') + r.open; Z('parens'), Y({ type: e, value: t, output: M.output ? '' : v }), Y({ type: 'paren', extglob: !0, value: F(), output: o }), B.push(r); }; const V = e => { let t = e.close + (n.capture ? ')' : ''); if (e.type === 'negate') { let r = I; e.inner && e.inner.length > 1 && e.inner.includes('/') && (r = w(n)), (r !== I || K() || /^\)+$/.test(Q())) && (t = e.close = `)$))${r}`), e.prev.type === 'bos' && K() && (M.negatedExtglob = !0); }Y({ type: 'paren', extglob: !0, value: G, output: t }), q('parens'); }; if (!1 !== n.fastpaths && !/(^[*!]|[/()[\]{}"])/.test(e)) { let r = !1; let i = e.replace(a, (e, t, n, o, i, s) => (o === '\\' ? (r = !0, e) : o === '?' ? t ? t + o + (i ? T.repeat(i.length) : '') : s === 0 ? k + (i ? T.repeat(i.length) : '') : T.repeat(n.length) : o === '.' ? E.repeat(n.length) : o === '*' ? t ? t + o + (i ? I : '') : I : t ? e : `\\${e}`)); return !0 === r && (i = !0 === n.unescape ? i.replace(/\\/g, '') : i.replace(/\\+/g, e => (e.length % 2 == 0 ? '\\\\' : e ? '\\' : ''))), i === e && !0 === n.contains ? (M.output = e, M) : (M.output = o.wrapOutput(i, M, t), M); } for (;!K();) { if ((G = F()) === '\0') { continue; } if (G === '\\') { const e = j(); if (e === '/' && !0 !== n.bash) { continue; } if (e === '.' || e === ';') { continue; } if (!e) { Y({ type: 'text', value: G += '\\' }); continue; } const t = /^\\+/.exec(Q()); let r = 0; if (t && t[0].length > 2 && (r = t[0].length, M.index += r, r % 2 != 0 && (G += '\\')), !0 === n.unescape ? G = F() || '' : G += F() || '', M.brackets === 0) { Y({ type: 'text', value: G }); continue; } } if (M.brackets > 0 && (G !== ']' || U.value === '[' || U.value === '[^')) { if (!1 !== n.posix && G === ':') { const e = U.value.slice(1); if (e.includes('[') && (U.posix = !0, e.includes(':'))) { const e = U.value.lastIndexOf('['); const t = U.value.slice(0, e); const n = U.value.slice(e + 2); const r = s[n]; if (r) { U.value = t + r, M.backtrack = !0, F(), h.output || A.indexOf(U) !== 1 || (h.output = v); continue; } } }(G === '[' && j() !== ':' || G === '-' && j() === ']') && (G = `\\${G}`), G !== ']' || U.value !== '[' && U.value !== '[^' || (G = `\\${G}`), !0 === n.posix && G === '!' && U.value === '[' && (G = '^'), U.value += G, X({ value: G }); continue; } if (M.quotes === 1 && G !== '"') { G = o.escapeRegex(G), U.value += G, X({ value: G }); continue; } if (G === '"') { M.quotes = M.quotes === 1 ? 0 : 1, !0 === n.keepQuotes && Y({ type: 'text', value: G }); continue; } if (G === '(') { Z('parens'), Y({ type: 'paren', value: G }); continue; } if (G === ')') { if (M.parens === 0 && !0 === n.strictBrackets) { throw new SyntaxError(c('opening', '(')); } const e = B[B.length - 1]; if (e && M.parens === e.parens + 1) { V(B.pop()); continue; }Y({ type: 'paren', value: G, output: M.parens ? ')' : '\\)' }), q('parens'); continue; } if (G === '[') { if (!0 !== n.nobracket && Q().includes(']')) { Z('brackets'); } else { if (!0 !== n.nobracket && !0 === n.strictBrackets) { throw new SyntaxError(c('closing', ']')); } G = `\\${G}`; }Y({ type: 'bracket', value: G }); continue; } if (G === ']') { if (!0 === n.nobracket || U && U.type === 'bracket' && U.value.length === 1) { Y({ type: 'text', value: G, output: `\\${G}` }); continue; } if (M.brackets === 0) { if (!0 === n.strictBrackets) { throw new SyntaxError(c('opening', '[')); } Y({ type: 'text', value: G, output: `\\${G}` }); continue; }q('brackets'); const e = U.value.slice(1); if (!0 === U.posix || e[0] !== '^' || e.includes('/') || (G = `/${G}`), U.value += G, X({ value: G }), !1 === n.literalBrackets || o.hasRegexChars(e)) { continue; } const t = o.escapeRegex(U.value); if (M.output = M.output.slice(0, -U.value.length), !0 === n.literalBrackets) { M.output += t, U.value = t; continue; }U.value = `(${y}${t}|${U.value})`, M.output += U.value; continue; } if (G === '{' && !0 !== n.nobrace) { Z('braces'); const e = { type: 'brace', value: G, output: '(', outputIndex: M.output.length, tokensIndex: M.tokens.length }; D.push(e), Y(e); continue; } if (G === '}') { const e = D[D.length - 1]; if (!0 === n.nobrace || !e) { Y({ type: 'text', value: G, output: G }); continue; } let t = ')'; if (!0 === e.dots) { const e = A.slice(); const r = []; for (let t = e.length - 1; t >= 0 && (A.pop(), e[t].type !== 'brace'); t--) { e[t].type !== 'dots' && r.unshift(e[t].value); } t = p(r, n), M.backtrack = !0; } if (!0 !== e.comma && !0 !== e.dots) { const n = M.output.slice(0, e.outputIndex); const r = M.tokens.slice(e.tokensIndex); e.value = e.output = '\\{', G = t = '\\}', M.output = n; for (const e of r) { M.output += e.output || e.value; } }Y({ type: 'brace', value: G, output: t }), q('braces'), D.pop(); continue; } if (G === '|') { B.length > 0 && B[B.length - 1].conditions++, Y({ type: 'text', value: G }); continue; } if (G === ',') { let e = G; const t = D[D.length - 1]; t && P[P.length - 1] === 'braces' && (t.comma = !0, e = '|'), Y({ type: 'comma', value: G, output: e }); continue; } if (G === '/') { if (U.type === 'dot' && M.index === M.start + 1) { M.start = M.index + 1, M.consumed = '', M.output = '', A.pop(), U = h; continue; }Y({ type: 'slash', value: G, output: C }); continue; } if (G === '.') { if (M.braces > 0 && U.type === 'dot') { U.value === '.' && (U.output = E); const e = D[D.length - 1]; U.type = 'dots', U.output += G, U.value += G, e.dots = !0; continue; } if (M.braces + M.parens === 0 && U.type !== 'bos' && U.type !== 'slash') { Y({ type: 'text', value: G, output: E }); continue; }Y({ type: 'dot', value: G, output: E }); continue; } if (G === '?') { if (!(U && U.value === '(') && !0 !== n.noextglob && j() === '(' && j(2) !== '?') { J('qmark', G); continue; } if (U && U.type === 'paren') { const e = j(); let t = G; if (e === '<' && !o.supportsLookbehinds()) { throw new Error('Node.js v10 or higher is required for regex lookbehinds'); } (U.value === '(' && !/[!=<:]/.test(e) || e === '<' && !/<([!=]|\w+>)/.test(Q())) && (t = `\\${G}`), Y({ type: 'text', value: G, output: t }); continue; } if (!0 !== n.dot && (U.type === 'slash' || U.type === 'bos')) { Y({ type: 'qmark', value: G, output: O }); continue; }Y({ type: 'qmark', value: G, output: T }); continue; } if (G === '!') { if (!0 !== n.noextglob && j() === '(' && (j(2) !== '?' || !/[!=<:]/.test(j(3)))) { J('negate', G); continue; } if (!0 !== n.nonegate && M.index === 0) { W(); continue; } } if (G === '+') { if (!0 !== n.noextglob && j() === '(' && j(2) !== '?') { J('plus', G); continue; } if (U && U.value === '(' || !1 === n.regex) { Y({ type: 'plus', value: G, output: b }); continue; } if (U && (U.type === 'bracket' || U.type === 'paren' || U.type === 'brace') || M.parens > 0) { Y({ type: 'plus', value: G }); continue; }Y({ type: 'plus', value: b }); continue; } if (G === '@') { if (!0 !== n.noextglob && j() === '(' && j(2) !== '?') { Y({ type: 'at', extglob: !0, value: G, output: '' }); continue; }Y({ type: 'text', value: G }); continue; } if (G !== '*') { G !== '$' && G !== '^' || (G = `\\${G}`); const e = u.exec(Q()); e && (G += e[0], M.index += e[0].length), Y({ type: 'text', value: G }); continue; } if (U && (U.type === 'globstar' || !0 === U.star)) { U.type = 'star', U.star = !0, U.value += G, U.output = I, M.backtrack = !0, M.globstar = !0, z(G); continue; } let t = Q(); if (!0 !== n.noextglob && /^\([^?]/.test(t)) { J('star', G); continue; } if (U.type === 'star') { if (!0 === n.noglobstar) { z(G); continue; } const r = U.prev; const o = r.prev; const i = r.type === 'slash' || r.type === 'bos'; const s = o && (o.type === 'star' || o.type === 'globstar'); if (!0 === n.bash && (!i || t[0] && t[0] !== '/')) { Y({ type: 'star', value: G, output: '' }); continue; } const u = M.braces > 0 && (r.type === 'comma' || r.type === 'brace'); const a = B.length && (r.type === 'pipe' || r.type === 'paren'); if (!i && r.type !== 'paren' && !u && !a) { Y({ type: 'star', value: G, output: '' }); continue; } for (;t.slice(0, 3) === '/**';) { const n = e[M.index + 4]; if (n && n !== '/') { break; } t = t.slice(3), z('/**', 3); } if (r.type === 'bos' && K()) { U.type = 'globstar', U.value += G, U.output = w(n), M.output = U.output, M.globstar = !0, z(G); continue; } if (r.type === 'slash' && r.prev.type !== 'bos' && !s && K()) { M.output = M.output.slice(0, -(r.output + U.output).length), r.output = `(?:${r.output}`, U.type = 'globstar', U.output = w(n) + (n.strictSlashes ? ')' : '|$)'), U.value += G, M.globstar = !0, M.output += r.output + U.output, z(G); continue; } if (r.type === 'slash' && r.prev.type !== 'bos' && t[0] === '/') { const e = void 0 !== t[1] ? '|$' : ''; M.output = M.output.slice(0, -(r.output + U.output).length), r.output = `(?:${r.output}`, U.type = 'globstar', U.output = `${w(n)}${C}|${C}${e})`, U.value += G, M.output += r.output + U.output, M.globstar = !0, z(G + F()), Y({ type: 'slash', value: '/', output: '' }); continue; } if (r.type === 'bos' && t[0] === '/') { U.type = 'globstar', U.value += G, U.output = `(?:^|${C}|${w(n)}${C})`, M.output = U.output, M.globstar = !0, z(G + F()), Y({ type: 'slash', value: '/', output: '' }); continue; }M.output = M.output.slice(0, -U.output.length), U.type = 'globstar', U.output = w(n), U.value += G, M.output += U.output, M.globstar = !0, z(G); continue; } const r = { type: 'star', value: G, output: I }; !0 !== n.bash ? !U || U.type !== 'bracket' && U.type !== 'paren' || !0 !== n.regex ? (M.index !== M.start && U.type !== 'slash' && U.type !== 'dot' || (U.type === 'dot' ? (M.output += S, U.output += S) : !0 === n.dot ? (M.output += H, U.output += H) : (M.output += N, U.output += N), j() !== '*' && (M.output += v, U.output += v)), Y(r)) : (r.output = G, Y(r)) : (r.output = '.*?', U.type !== 'bos' && U.type !== 'slash' || (r.output = N + r.output), Y(r)); } for (;M.brackets > 0;) { if (!0 === n.strictBrackets) { throw new SyntaxError(c('closing', ']')); } M.output = o.escapeLast(M.output, '['), q('brackets'); } for (;M.parens > 0;) { if (!0 === n.strictBrackets) { throw new SyntaxError(c('closing', ')')); } M.output = o.escapeLast(M.output, '('), q('parens'); } for (;M.braces > 0;) { if (!0 === n.strictBrackets) { throw new SyntaxError(c('closing', '}')); } M.output = o.escapeLast(M.output, '{'), q('braces'); } if (!0 === n.strictSlashes || U.type !== 'star' && U.type !== 'bracket' || Y({ type: 'maybe_slash', value: '', output: `${C}?` }), !0 === M.backtrack) { M.output = ''; for (const e of M.tokens) { M.output += e.output != null ? e.output : e.value, e.suffix && (M.output += e.suffix); } } return M; }; f.fastpaths = ((e, t) => { const n = { ...t }; const s = typeof n.maxLength === 'number' ? Math.min(i, n.maxLength) : i; const u = e.length; if (u > s) { throw new SyntaxError(`Input length: ${u}, exceeds maximum allowed length: ${s}`); } e = l[e] || e; const a = o.isWindows(t); const { DOT_LITERAL:p, SLASH_LITERAL:c, ONE_CHAR:f, DOTS_SLASH:g, NO_DOT:h, NO_DOTS:A, NO_DOTS_SLASH:y, STAR:R, START_ANCHOR:d } = r.globChars(a); const _ = n.dot ? A : h; const E = n.dot ? y : h; const b = n.capture ? '' : '?:'; let C = !0 === n.bash ? '.*?' : R; n.capture && (C = `(${C})`); const v = e => (!0 === e.noglobstar ? C : `(${b}(?:(?!${d}${e.dot ? g : p}).)*?)`); const x = e => { switch (e) { case '*': return `${_}${f}${C}`; case '.*': return `${p}${f}${C}`; case '*.*': return `${_}${C}${p}${f}${C}`; case '*/*': return `${_}${C}${c}${f}${E}${C}`; case '**': return _ + v(n); case '**/*': return `(?:${_}${v(n)}${c})?${E}${f}${C}`; case '**/*.*': return `(?:${_}${v(n)}${c})?${E}${C}${p}${f}${C}`; case '**/.*': return `(?:${_}${v(n)}${c})?${p}${f}${C}`; default: { const t = /^(.*?)\.(\w+)$/.exec(e); if (!t) { return; } const n = x(t[1]); if (!n) { return; } return n + p + t[2]; } } }; const m = o.removePrefix(e, { negated: !1, prefix: '' }); let S = x(m); return S && !0 !== n.strictSlashes && (S += `${c}?`), S; }), t.exports = f; }, { './constants': 12, './utils': 16 }], 14: [ function (e, t, n) { 'use strict'; const r = e('path'); const o = e('./scan'); const i = e('./parse'); const s = e('./utils'); const u = e('./constants'); const a = (e, t, n = !1) => { if (Array.isArray(e)) { const r = e.map(e => a(e, t, n)); return e => { for (const t of r) { const n = t(e); if (n) { return n; } } return !1; }; } const r = (e => e && typeof e === 'object' && !Array.isArray(e))(e) && e.tokens && e.input; if (e === '' || typeof e !== 'string' && !r) { throw new TypeError('Expected pattern to be a non-empty string'); } const o = t || {}; const i = s.isWindows(t); const u = r ? a.compileRe(e, t) : a.makeRe(e, t, !1, !0); const l = u.state; delete u.state; let p = () => !1; if (o.ignore) { const e = { ...t, ignore: null, onMatch: null, onResult: null }; p = a(o.ignore, e, n); } const c = (n, r = !1) => { const { isMatch:s, match:c, output:f } = a.test(n, u, t, { glob: e, posix: i }); const g = { glob: e, state: l, regex: u, posix: i, input: n, output: f, match: c, isMatch: s }; return typeof o.onResult === 'function' && o.onResult(g), !1 === s ? (g.isMatch = !1, !!r && g) : p(n) ? (typeof o.onIgnore === 'function' && o.onIgnore(g), g.isMatch = !1, !!r && g) : (typeof o.onMatch === 'function' && o.onMatch(g), !r || g); }; return n && (c.state = l), c; }; a.test = ((e, t, n, { glob:r, posix:o } = {}) => { if (typeof e !== 'string') { throw new TypeError('Expected input to be a string'); } if (e === '') { return { isMatch: !1, output: '' }; } const i = n || {}; const u = i.format || (o ? s.toPosixSlashes : null); let l = e === r; let p = l && u ? u(e) : e; return !1 === l && (l = (p = u ? u(e) : e) === r), !1 !== l && !0 !== i.capture || (l = !0 === i.matchBase || !0 === i.basename ? a.matchBase(e, t, n, o) : t.exec(p)), { isMatch: Boolean(l), match: l, output: p }; }), a.matchBase = ((e, t, n, o = s.isWindows(n)) => { return (t instanceof RegExp ? t : a.makeRe(t, n)).test(r.basename(e)); }), a.isMatch = ((e, t, n) => a(t, n)(e)), a.parse = ((e, t) => (Array.isArray(e) ? e.map(e => a.parse(e, t)) : i(e, { ...t, fastpaths: !1 }))), a.scan = ((e, t) => o(e, t)), a.compileRe = ((e, t, n = !1, r = !1) => { if (!0 === n) { return e.output; } const o = t || {}; const i = o.contains ? '' : '^'; const s = o.contains ? '' : '$'; let u = `${i}(?:${e.output})${s}`; e && !0 === e.negated && (u = `^(?!${u}).*$`); const l = a.toRegex(u, t); return !0 === r && (l.state = e), l; }), a.makeRe = ((e, t, n = !1, r = !1) => { if (!e || typeof e !== 'string') { throw new TypeError('Expected a non-empty string'); } const o = t || {}; let s; let u = { negated: !1, fastpaths: !0 }; let l = ''; return e.startsWith('./') && (e = e.slice(2), l = u.prefix = './'), !1 === o.fastpaths || e[0] !== '.' && e[0] !== '*' || (s = i.fastpaths(e, t)), void 0 === s ? (u = i(e, t)).prefix = l + (u.prefix || '') : u.output = s, a.compileRe(u, t, n, r); }), a.toRegex = ((e, t) => { try { const n = t || {}; return new RegExp(e, n.flags || (n.nocase ? 'i' : '')); } catch (e) { if (t && !0 === t.debug) { throw e; } return /$^/; } }), a.constants = u, t.exports = a; }, { './constants': 12, './parse': 13, './scan': 15, './utils': 16, 'path': 18 }], 15: [ function (e, t, n) { 'use strict'; const r = e('./utils'); const { CHAR_ASTERISK:o, CHAR_AT:i, CHAR_BACKWARD_SLASH:s, CHAR_COMMA:u, CHAR_DOT:a, CHAR_EXCLAMATION_MARK:l, CHAR_FORWARD_SLASH:p, CHAR_LEFT_CURLY_BRACE:c, CHAR_LEFT_PARENTHESES:f, CHAR_LEFT_SQUARE_BRACKET:g, CHAR_PLUS:h, CHAR_QUESTION_MARK:A, CHAR_RIGHT_CURLY_BRACE:y, CHAR_RIGHT_PARENTHESES:R, CHAR_RIGHT_SQUARE_BRACKET:d } = e('./constants'); const _ = e => e === p || e === s; const E = e => { !0 !== e.isPrefix && (e.depth = e.isGlobstar ? 1 / 0 : 1); }; t.exports = ((e, t) => { const n = t || {}; const b = e.length - 1; const C = !0 === n.parts || !0 === n.scanToEnd; const v = []; const x = []; const m = []; let S; let H; let T = e; let O = -1; let $ = 0; let L = 0; let w = !1; let N = !1; let k = !1; let I = !1; let M = !1; let B = !1; let D = !1; let P = !1; let G = !1; let U = 0; let K = { value: '', depth: 0, isGlob: !1 }; const j = () => O >= b; const F = () => T.charCodeAt(O + 1); const Q = () => (S = H, T.charCodeAt(++O)); for (;O < b;) { let e; if ((H = Q()) !== s) { if (!0 === B || H === c) { for (U++; !0 !== j() && (H = Q());) { if (H !== s) { if (H !== c) { if (!0 !== B && H === a && (H = Q()) === a) { if (w = K.isBrace = !0, k = K.isGlob = !0, G = !0, !0 === C) { continue; } break; } if (!0 !== B && H === u) { if (w = K.isBrace = !0, k = K.isGlob = !0, G = !0, !0 === C) { continue; } break; } if (H === y && --U == 0) { B = !1, w = K.isBrace = !0, G = !0; break; } } else { U++; } } else { D = K.backslashes = !0, Q(); } } if (!0 === C) { continue; } break; } if (H !== p) { if (!0 !== n.noext && !0 == (H === h || H === i || H === o || H === A || H === l) && F() === f) { if (k = K.isGlob = !0, I = K.isExtglob = !0, G = !0, !0 === C) { for (;!0 !== j() && (H = Q());) { if (H !== s) { if (H === R) { k = K.isGlob = !0, G = !0; break; } } else { D = K.backslashes = !0, H = Q(); } } continue; } break; } if (H === o) { if (S === o && (M = K.isGlobstar = !0), k = K.isGlob = !0, G = !0, !0 === C) { continue; } break; } if (H === A) { if (k = K.isGlob = !0, G = !0, !0 === C) { continue; } break; } if (H === g) { for (;!0 !== j() && (e = Q());) { if (e !== s) { if (e === d) { if (N = K.isBracket = !0, k = K.isGlob = !0, G = !0, !0 === C) { continue; } break; } } else { D = K.backslashes = !0, Q(); } } } if (!0 === n.nonegate || H !== l || O !== $) { if (!0 !== n.noparen && H === f) { if (k = K.isGlob = !0, !0 === C) { for (;!0 !== j() && (H = Q());) { if (H !== f) { if (H === R) { G = !0; break; } } else { D = K.backslashes = !0, H = Q(); } } continue; } break; } if (!0 === k) { if (G = !0, !0 === C) { continue; } break; } } else { P = K.negated = !0, $++; } } else { if (v.push(O), x.push(K), K = { value: '', depth: 0, isGlob: !1 }, !0 === G) { continue; } if (S === a && O === $ + 1) { $ += 2; continue; }L = O + 1; } } else { D = K.backslashes = !0, (H = Q()) === c && (B = !0); } }!0 === n.noext && (I = !1, k = !1); let z = T; let X = ''; let W = ''; $ > 0 && (X = T.slice(0, $), T = T.slice($), L -= $), z && !0 === k && L > 0 ? (z = T.slice(0, L), W = T.slice(L)) : !0 === k ? (z = '', W = T) : z = T, z && z !== '' && z !== '/' && z !== T && _(z.charCodeAt(z.length - 1)) && (z = z.slice(0, -1)), !0 === n.unescape && (W && (W = r.removeBackslashes(W)), z && !0 === D && (z = r.removeBackslashes(z))); const Z = { prefix: X, input: e, start: $, base: z, glob: W, isBrace: w, isBracket: N, isGlob: k, isExtglob: I, isGlobstar: M, negated: P }; if (!0 === n.tokens && (Z.maxDepth = 0, _(H) || x.push(K), Z.tokens = x), !0 === n.parts || !0 === n.tokens) { let t; for (let r = 0; r < v.length; r++) { const o = t ? t + 1 : $; const i = v[r]; const s = e.slice(o, i); n.tokens && (r === 0 && $ !== 0 ? (x[r].isPrefix = !0, x[r].value = X) : x[r].value = s, E(x[r]), Z.maxDepth += x[r].depth), r === 0 && s === '' || m.push(s), t = i; } if (t && t + 1 < e.length) { const r = e.slice(t + 1); m.push(r), n.tokens && (x[x.length - 1].value = r, E(x[x.length - 1]), Z.maxDepth += x[x.length - 1].depth); }Z.slashes = v, Z.parts = m; } return Z; }); }, { './constants': 12, './utils': 16 }], 16: [ function (e, t, n) { (function (t) { 'use strict'; const r = e('path'); const o = t.platform === 'win32'; const { REGEX_BACKSLASH:i, REGEX_REMOVE_BACKSLASH:s, REGEX_SPECIAL_CHARS:u, REGEX_SPECIAL_CHARS_GLOBAL:a } = e('./constants'); n.isObject = (e => e !== null && typeof e === 'object' && !Array.isArray(e)), n.hasRegexChars = (e => u.test(e)), n.isRegexChar = (e => e.length === 1 && n.hasRegexChars(e)), n.escapeRegex = (e => e.replace(a, '\\$1')), n.toPosixSlashes = (e => e.replace(i, '/')), n.removeBackslashes = (e => e.replace(s, e => (e === '\\' ? '' : e))), n.supportsLookbehinds = (() => { const e = t.version.slice(1).split('.').map(Number); return e.length === 3 && e[0] >= 9 || e[0] === 8 && e[1] >= 10; }), n.isWindows = (e => (e && typeof e.windows === 'boolean' ? e.windows : !0 === o || r.sep === '\\')), n.escapeLast = ((e, t, r) => { const o = e.lastIndexOf(t, r); return o === -1 ? e : e[o - 1] === '\\' ? n.escapeLast(e, t, o - 1) : `${e.slice(0, o)}\\${e.slice(o)}`; }), n.removePrefix = ((e, t = {}) => { let n = e; return n.startsWith('./') && (n = n.slice(2), t.prefix = './'), n; }), n.wrapOutput = ((e, t = {}, n = {}) => { let r = `${n.contains ? '' : '^'}(?:${e})${n.contains ? '' : '$'}`; return !0 === t.negated && (r = `(?:^(?!${r}).*$)`), r; }); }).call(this, e('_process')); }, { './constants': 12, '_process': 19, 'path': 18 }], 17: [ function (e, t, n) { 'use strict'; const r = e('is-number'); const o = (e, t, n) => { if (!1 === r(e)) { throw new TypeError('toRegexRange: expected the first argument to be a number'); } if (void 0 === t || e === t) { return String(e); } if (!1 === r(t)) { throw new TypeError('toRegexRange: expected the second argument to be a number.'); } const i = { relaxZeros: !0, ...n }; typeof i.strictZeros === 'boolean' && (i.relaxZeros = !1 === i.strictZeros); const a = `${e}:${t}=${String(i.relaxZeros)}${String(i.shorthand)}${String(i.capture)}${String(i.wrap)}`; if (o.cache.hasOwnProperty(a)) { return o.cache[a].result; } let l = Math.min(e, t); const p = Math.max(e, t); if (Math.abs(l - p) === 1) { const n = `${e}|${t}`; return i.capture ? `(${n})` : !1 === i.wrap ? n : `(?:${n})`; } const c = h(e) || h(t); const f = { min: e, max: t, a: l, b: p }; let g = []; let A = []; if (c && (f.isPadded = c, f.maxLen = String(f.max).length), l < 0) { A = s(p < 0 ? Math.abs(p) : 1, Math.abs(l), f, i), l = f.a = 0; } return p >= 0 && (g = s(l, p, f, i)), f.negatives = A, f.positives = g, f.result = (function (e, t, n) { const r = u(e, t, '-', !1, n) || []; const o = u(t, e, '', !1, n) || []; const i = u(e, t, '-?', !0, n) || []; return r.concat(i).concat(o).join('|'); }(A, g, i)), !0 === i.capture ? f.result = `(${f.result})` : !1 !== i.wrap && g.length + A.length > 1 && (f.result = `(?:${f.result})`), o.cache[a] = f, f.result; }; function i(e, t, n) { if (e === t) { return { pattern: e, count: [], digits: 0 }; } const r = (function (e, t) { const n = []; for (let r = 0; r < e.length; r++) { n.push([ e[r], t[r] ]); } return n; }(e, t)); const o = r.length; let i = ''; let s = 0; for (let e = 0; e < o; e++) { const [ t, o ] = r[e]; t === o ? i += t : t !== '0' || o !== '9' ? i += g(t, o, n) : s++; } return s && (i += !0 === n.shorthand ? '\\d' : '[0-9]'), { pattern: i, count: [ s ], digits: o }; } function s(e, t, n, r) { let o; const s = (function (e, t) { let n = 1; let r = 1; let o = p(e, n); let i = new Set([ t ]); for (;e <= o && o <= t;) { i.add(o), o = p(e, n += 1); } for (o = c(t + 1, r) - 1; e < o && o <= t;) { i.add(o), o = c(t + 1, r += 1) - 1; } return (i = [ ...i ]).sort(a), i; }(e, t)); const u = []; let l = e; for (let e = 0; e < s.length; e++) { const t = s[e]; const a = i(String(l), String(t), r); let p = ''; n.isPadded || !o || o.pattern !== a.pattern ? (n.isPadded && (p = A(t, n, r)), a.string = p + a.pattern + f(a.count), u.push(a), l = t + 1, o = a) : (o.count.length > 1 && o.count.pop(), o.count.push(a.count[0]), o.string = o.pattern + f(o.count), l = t + 1); } return u; } function u(e, t, n, r, o) { const i = []; for (const o of e) { const { string:e } = o; r || l(t, 'string', e) || i.push(n + e), r && l(t, 'string', e) && i.push(n + e); } return i; } function a(e, t) { return e > t ? 1 : t > e ? -1 : 0; } function l(e, t, n) { return e.some(e => e[t] === n); } function p(e, t) { return Number(String(e).slice(0, -t) + '9'.repeat(t)); } function c(e, t) { return e - e % Math.pow(10, t); } function f(e) { const [ t = 0, n = '' ] = e; return n || t > 1 ? `{${t + (n ? `,${n}` : '')}}` : ''; } function g(e, t, n) { return `[${e}${t - e == 1 ? '' : '-'}${t}]`; } function h(e) { return /^-?(0+)\d/.test(e); } function A(e, t, n) { if (!t.isPadded) { return e; } const r = Math.abs(t.maxLen - String(e).length); const o = !1 !== n.relaxZeros; switch (r) { case 0: return ''; case 1: return o ? '0?' : '0'; case 2: return o ? '0{0,2}' : '00'; default: return o ? `0{0,${r}}` : `0{${r}}`; } }o.cache = {}, o.clearCache = (() => o.cache = {}), t.exports = o; }, { 'is-number': 10 }], 18: [ function (e, t, n) { (function (e) { function t(e, t) { for (var n = 0, r = e.length - 1; r >= 0; r--) { const o = e[r]; o === '.' ? e.splice(r, 1) : o === '..' ? (e.splice(r, 1), n++) : n && (e.splice(r, 1), n--); } if (t) { for (;n--; n) { e.unshift('..'); } } return e; } function r(e, t) { if (e.filter) { return e.filter(t); } for (var n = [], r = 0; r < e.length; r++) { t(e[r], r, e) && n.push(e[r]); } return n; }n.resolve = function () { for (var n = '', o = !1, i = arguments.length - 1; i >= -1 && !o; i--) { const s = i >= 0 ? arguments[i] : e.cwd(); if (typeof s !== 'string') { throw new TypeError('Arguments to path.resolve must be strings'); } s && (n = `${s}/${n}`, o = s.charAt(0) === '/'); } return (o ? '/' : '') + (n = t(r(n.split('/'), e => { return !!e; }), !o).join('/')) || '.'; }, n.normalize = function (e) { const i = n.isAbsolute(e); const s = o(e, -1) === '/'; return (e = t(r(e.split('/'), e => { return !!e; }), !i).join('/')) || i || (e = '.'), e && s && (e += '/'), (i ? '/' : '') + e; }, n.isAbsolute = function (e) { return e.charAt(0) === '/'; }, n.join = function () { const e = Array.prototype.slice.call(arguments, 0); return n.normalize(r(e, (e, t) => { if (typeof e !== 'string') { throw new TypeError('Arguments to path.join must be strings'); } return e; }).join('/')); }, n.relative = function (e, t) { function r(e) { for (var t = 0; t < e.length && e[t] === ''; t++) {  } for (var n = e.length - 1; n >= 0 && e[n] === ''; n--) {  } return t > n ? [] : e.slice(t, n - t + 1); }e = n.resolve(e).substr(1), t = n.resolve(t).substr(1); for (var o = r(e.split('/')), i = r(t.split('/')), s = Math.min(o.length, i.length), u = s, a = 0; a < s; a++) { if (o[a] !== i[a]) { u = a; break; } } let l = []; for (a = u; a < o.length; a++) { l.push('..'); } return (l = l.concat(i.slice(u))).join('/'); }, n.sep = '/', n.delimiter = ':', n.dirname = function (e) { if (typeof e !== 'string' && (e += ''), e.length === 0) { return '.'; } for (var t = e.charCodeAt(0), n = t === 47, r = -1, o = !0, i = e.length - 1; i >= 1; --i) { if ((t = e.charCodeAt(i)) === 47) { if (!o) { r = i; break; } } else { o = !1; } } return r === -1 ? n ? '/' : '.' : n && r === 1 ? '/' : e.slice(0, r); }, n.basename = function (e, t) { let n = (function (e) { typeof e !== 'string' && (e += ''); let t; let n = 0; let r = -1; let o = !0; for (t = e.length - 1; t >= 0; --t) { if (e.charCodeAt(t) === 47) { if (!o) { n = t + 1; break; } } else { r === -1 && (o = !1, r = t + 1); } } return r === -1 ? '' : e.slice(n, r); }(e)); return t && n.substr(-1 * t.length) === t && (n = n.substr(0, n.length - t.length)), n; }, n.extname = function (e) { typeof e !== 'string' && (e += ''); for (var t = -1, n = 0, r = -1, o = !0, i = 0, s = e.length - 1; s >= 0; --s) { const u = e.charCodeAt(s); if (u !== 47) { r === -1 && (o = !1, r = s + 1), u === 46 ? t === -1 ? t = s : i !== 1 && (i = 1) : t !== -1 && (i = -1); } else if (!o) { n = s + 1; break; } } return t === -1 || r === -1 || i === 0 || i === 1 && t === r - 1 && t === n + 1 ? '' : e.slice(t, r); }; var o = 'ab'.substr(-1) === 'b' ? function (e, t, n) { return e.substr(t, n); } : function (e, t, n) { return t < 0 && (t = e.length + t), e.substr(t, n); }; }).call(this, e('_process')); }, { _process: 19 }], 19: [ function (e, t, n) { let r; let o; const i = t.exports = {}; function s() { throw new Error('setTimeout has not been defined'); } function u() { throw new Error('clearTimeout has not been defined'); } function a(e) { if (r === setTimeout) { return setTimeout(e, 0); } if ((r === s || !r) && setTimeout) { return r = setTimeout, setTimeout(e, 0); } try { return r(e, 0); } catch (t) { try { return r.call(null, e, 0); } catch (t) { return r.call(this, e, 0); } } }!(function () { try { r = typeof setTimeout === 'function' ? setTimeout : s; } catch (e) { r = s; } try { o = typeof clearTimeout === 'function' ? clearTimeout : u; } catch (e) { o = u; } }()); let l; let p = []; let c = !1; let f = -1; function g() { c && l && (c = !1, l.length ? p = l.concat(p) : f = -1, p.length && h()); } function h() { if (!c) { const e = a(g); c = !0; for (let t = p.length; t;) { for (l = p, p = []; ++f < t;) { l && l[f].run(); }f = -1, t = p.length; }l = null, c = !1, (function (e) { if (o === clearTimeout) { return clearTimeout(e); } if ((o === u || !o) && clearTimeout) { return o = clearTimeout, clearTimeout(e); } try { o(e); } catch (t) { try { return o.call(null, e); } catch (t) { return o.call(this, e); } } }(e)); } } function A(e, t) { this.fun = e, this.array = t; } function y() {}i.nextTick = function (e) { const t = new Array(arguments.length - 1); if (arguments.length > 1) { for (let n = 1; n < arguments.length; n++) { t[n - 1] = arguments[n]; } }p.push(new A(e, t)), p.length !== 1 || c || a(h); }, A.prototype.run = function () { this.fun.apply(null, this.array); }, i.title = 'browser', i.browser = !0, i.env = {}, i.argv = [], i.version = '', i.versions = {}, i.on = y, i.addListener = y, i.once = y, i.off = y, i.removeListener = y, i.removeAllListeners = y, i.emit = y, i.prependListener = y, i.prependOnceListener = y, i.listeners = function (e) { return []; }, i.binding = function (e) { throw new Error('process.binding is not supported'); }, i.cwd = function () { return '/'; }, i.chdir = function (e) { throw new Error('process.chdir is not supported'); }, i.umask = function () { return 0; }; }, {}], 20: [ function (e, t, n) { typeof Object.create === 'function' ? t.exports = function (e, t) { e.super_ = t, e.prototype = Object.create(t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }); } : t.exports = function (e, t) { e.super_ = t; const n = function () {}; n.prototype = t.prototype, e.prototype = new n(), e.prototype.constructor = e; }; }, {}], 21: [ function (e, t, n) { t.exports = function (e) { return e && typeof e === 'object' && typeof e.copy === 'function' && typeof e.fill === 'function' && typeof e.readUInt8 === 'function'; }; }, {}], 22: [ function (e, t, n) { (function (t, r) { const o = /%[sdj%]/g; n.format = function (e) { if (!R(e)) { for (var t = [], n = 0; n < arguments.length; n++) { t.push(u(arguments[n])); } return t.join(' '); }n = 1; for (var r = arguments, i = r.length, s = String(e).replace(o, e => { if (e === '%%') { return '%'; } if (n >= i) { return e; } switch (e) { case '%s': return String(r[n++]); case '%d': return Number(r[n++]); case '%j': try { return JSON.stringify(r[n++]); } catch (e) { return '[Circular]'; } default: return e; } }), a = r[n]; n < i; a = r[++n]) { A(a) || !E(a) ? s += ` ${a}` : s += ` ${u(a)}`; } return s; }, n.deprecate = function (e, o) { if (d(r.process)) { return function () { return n.deprecate(e, o).apply(this, arguments); }; } if (!0 === t.noDeprecation) { return e; } let i = !1; return function () { if (!i) { if (t.throwDeprecation) { throw new Error(o); } t.traceDeprecation ? console.trace(o) : console.error(o), i = !0; } return e.apply(this, arguments); }; }; let i; const s = {}; function u(e, t) { const r = { seen: [], stylize: l }; return arguments.length >= 3 && (r.depth = arguments[2]), arguments.length >= 4 && (r.colors = arguments[3]), h(t) ? r.showHidden = t : t && n._extend(r, t), d(r.showHidden) && (r.showHidden = !1), d(r.depth) && (r.depth = 2), d(r.colors) && (r.colors = !1), d(r.customInspect) && (r.customInspect = !0), r.colors && (r.stylize = a), p(r, e, r.depth); } function a(e, t) { const n = u.styles[t]; return n ? `[${u.colors[n][0]}m${e}[${u.colors[n][1]}m` : e; } function l(e, t) { return e; } function p(e, t, r) { if (e.customInspect && t && v(t.inspect) && t.inspect !== n.inspect && (!t.constructor || t.constructor.prototype !== t)) { let o = t.inspect(r, e); return R(o) || (o = p(e, o, r)), o; } const i = (function (e, t) { if (d(t)) { return e.stylize('undefined', 'undefined'); } if (R(t)) { const n = `'${JSON.stringify(t).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"')}'`; return e.stylize(n, 'string'); } if (y(t)) { return e.stylize(`${t}`, 'number'); } if (h(t)) { return e.stylize(`${t}`, 'boolean'); } if (A(t)) { return e.stylize('null', 'null'); } }(e, t)); if (i) { return i; } let s = Object.keys(t); const u = (function (e) { const t = {}; return e.forEach((e, n) => { t[e] = !0; }), t; }(s)); if (e.showHidden && (s = Object.getOwnPropertyNames(t)), C(t) && (s.indexOf('message') >= 0 || s.indexOf('description') >= 0)) { return c(t); } if (s.length === 0) { if (v(t)) { const a = t.name ? `: ${t.name}` : ''; return e.stylize(`[Function${a}]`, 'special'); } if (_(t)) { return e.stylize(RegExp.prototype.toString.call(t), 'regexp'); } if (b(t)) { return e.stylize(Date.prototype.toString.call(t), 'date'); } if (C(t)) { return c(t); } } let l; let E = ''; let x = !1; let m = [ '{', '}' ]; (g(t) && (x = !0, m = [ '[', ']' ]), v(t)) && (E = ` [Function${t.name ? `: ${t.name}` : ''}]`); return _(t) && (E = ` ${RegExp.prototype.toString.call(t)}`), b(t) && (E = ` ${Date.prototype.toUTCString.call(t)}`), C(t) && (E = ` ${c(t)}`), s.length !== 0 || x && t.length != 0 ? r < 0 ? _(t) ? e.stylize(RegExp.prototype.toString.call(t), 'regexp') : e.stylize('[Object]', 'special') : (e.seen.push(t), l = x ? (function (e, t, n, r, o) { for (var i = [], s = 0, u = t.length; s < u; ++s) { H(t, String(s)) ? i.push(f(e, t, n, r, String(s), !0)) : i.push(''); } return o.forEach(o => { o.match(/^\d+$/) || i.push(f(e, t, n, r, o, !0)); }), i; }(e, t, r, u, s)) : s.map(n => { return f(e, t, r, u, n, x); }), e.seen.pop(), (function (e, t, n) { if (e.reduce((e, t) => { return 0, t.indexOf('\n') >= 0 && 0, e + t.replace(/\u001b\[\d\d?m/g, '').length + 1; }, 0) > 60) { return `${n[0] + (t === '' ? '' : `${t}\n `)} ${e.join(',\n  ')} ${n[1]}`; } return `${n[0] + t} ${e.join(', ')} ${n[1]}`; }(l, E, m))) : m[0] + E + m[1]; } function c(e) { return `[${Error.prototype.toString.call(e)}]`; } function f(e, t, n, r, o, i) { let s; let u; let a; if ((a = Object.getOwnPropertyDescriptor(t, o) || { value: t[o] }).get ? u = a.set ? e.stylize('[Getter/Setter]', 'special') : e.stylize('[Getter]', 'special') : a.set && (u = e.stylize('[Setter]', 'special')), H(r, o) || (s = `[${o}]`), u || (e.seen.indexOf(a.value) < 0 ? (u = A(n) ? p(e, a.value, null) : p(e, a.value, n - 1)).indexOf('\n') > -1 && (u = i ? u.split('\n').map(e => { return `  ${e}`; }).join('\n').substr(2) : `\n${u.split('\n').map(e => { return `   ${e}`; }).join('\n')}`) : u = e.stylize('[Circular]', 'special')), d(s)) { if (i && o.match(/^\d+$/)) { return u; } (s = JSON.stringify(`${o}`)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (s = s.substr(1, s.length - 2), s = e.stylize(s, 'name')) : (s = s.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), s = e.stylize(s, 'string')); } return `${s}: ${u}`; } function g(e) { return Array.isArray(e); } function h(e) { return typeof e === 'boolean'; } function A(e) { return e === null; } function y(e) { return typeof e === 'number'; } function R(e) { return typeof e === 'string'; } function d(e) { return void 0 === e; } function _(e) { return E(e) && x(e) === '[object RegExp]'; } function E(e) { return typeof e === 'object' && e !== null; } function b(e) { return E(e) && x(e) === '[object Date]'; } function C(e) { return E(e) && (x(e) === '[object Error]' || e instanceof Error); } function v(e) { return typeof e === 'function'; } function x(e) { return Object.prototype.toString.call(e); } function m(e) { return e < 10 ? `0${e.toString(10)}` : e.toString(10); }n.debuglog = function (e) { if (d(i) && (i = t.env.NODE_DEBUG || ''), e = e.toUpperCase(), !s[e]) { if (new RegExp(`\\b${e}\\b`, 'i').test(i)) { const r = t.pid; s[e] = function () { const t = n.format.apply(n, arguments); console.error('%s %d: %s', e, r, t); }; } else { s[e] = function () {}; } } return s[e]; }, n.inspect = u, u.colors = { bold: [ 1, 22 ], italic: [ 3, 23 ], underline: [ 4, 24 ], inverse: [ 7, 27 ], white: [ 37, 39 ], grey: [ 90, 39 ], black: [ 30, 39 ], blue: [ 34, 39 ], cyan: [ 36, 39 ], green: [ 32, 39 ], magenta: [ 35, 39 ], red: [ 31, 39 ], yellow: [ 33, 39 ] }, u.styles = { special: 'cyan', number: 'yellow', boolean: 'yellow', undefined: 'grey', null: 'bold', string: 'green', date: 'magenta', regexp: 'red' }, n.isArray = g, n.isBoolean = h, n.isNull = A, n.isNullOrUndefined = function (e) { return e == null; }, n.isNumber = y, n.isString = R, n.isSymbol = function (e) { return typeof e === 'symbol'; }, n.isUndefined = d, n.isRegExp = _, n.isObject = E, n.isDate = b, n.isError = C, n.isFunction = v, n.isPrimitive = function (e) { return e === null || typeof e === 'boolean' || typeof e === 'number' || typeof e === 'string' || typeof e === 'symbol' || void 0 === e; }, n.isBuffer = e('./support/isBuffer'); const S = [ 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec' ]; function H(e, t) { return Object.prototype.hasOwnProperty.call(e, t); }n.log = function () { let e; let t; console.log('%s - %s', (e = new Date(), t = [ m(e.getHours()), m(e.getMinutes()), m(e.getSeconds()) ].join(':'), [ e.getDate(), S[e.getMonth()], t ].join(' ')), n.format.apply(n, arguments)); }, n.inherits = e('inherits'), n._extend = function (e, t) { if (!t || !E(t)) { return e; } for (let n = Object.keys(t), r = n.length; r--;) { e[n[r]] = t[n[r]]; } return e; }; }).call(this, e('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}); }, { './support/isBuffer': 21, '_process': 19, 'inherits': 20 }],
	}, {}, [ 1 ])(1);
}));
